##1장 들어가기

### 아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라
장점 
1. 이름을 가질 수 있다. </br>
</t> - 객체의 특성 파악이 용이함
    
2. 호출 될 때마다, 인스턴스를  새로 생성하지 않아도 된다. </br>
   - 불변 클래스는 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용 하는 식으로 불필요한 객체 생성을 피할 수 있다. 
     (ex. Boolean.valueOf(boolean) :: 객체를 아예 생성 하지 않음 )
     => 이는 같은 객체가 자주 요청되는 상황이라면 성능을 많이 끌어올려 줌
     >인스턴스 통제 클래스 : 반복되는 요청에 같은 객체를 반환하는 식의 정적 팩터리 방식의 클레스, 언제 어느 인스턴스를 살아있게 할지를 철저히 통제 할 수 있는 클래스 
      </br>=>인스턴스 통제는 플라이 웨이트 패턴의 근간이 되며, 열거 타입은 인스턴스가 하나만 만들어짐을 보장한다.  

3. 반환 타입의 하위 객체를 반환할 수 있는 능력이 있다. 
   - 반환할 객체의 클래스를 자유롭게 선택 할 수 있게 하는 유연성 제공
   - Java8 부터는 인터페이스가 정적 메서드를 가질 수 있다. 
    <br>단, 정적 필드와 정적 멤버 클래스는 여전히 public 이어야 함. 
    
4. 입력 매개 변수에 따라 매번 다른 클래스를 반환 할 수 있다. 
   
5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다. 

단점 
1. 상속하면 public 이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.
- 생성자 처럼 API 설명에 명확히 드러나지 않으니 사용자는 정적  팩터리 메서드 방식 클래스를 인스턴스화 할 방법을 알아내야 한다. 

정적 팩터리 메서드에서 흔히 사용하는 명명 방식
> 1. from : 매게변수를 하나 받아서 해당 타입의 인스트스를 반환하는 형변환 메서드
> 2. of : 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
> 3. valueOf : from 과 of의 더 자세한 버전
> 4. instance 혹은 getInstance : 매개변수를 받는 다면, 배개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지 않는다. 
> 5. create 혹은 NewInstance : instance or getInstance와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장
> 6. getType : getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할때 쓴다. Type 은 팩터리 메서드가 반환할 객체의 타입이다.
> 7. newType:NewInstance와 같으나,  생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할때 쓴다. Type 은 팩터리 메서드가 반환할 객체의 타입이다. 
> 8. type : getType과 NewType의 간결한 버전


<pre> 생성자란 ? 
</br> 정적 팩토리 매서드 => 디자인 패턴 메서드와 다르다!</pre>


### 아이템 2. 생성자에 매개변수가 많다면 빌더를 고려하라
- 매개변수가 많으면 접충적 생성자 패턴도 쓸 수는 있지만, 매개변수 개수가 만아지면 클라이언트 코드를 작성하거나 읽기 어렵다. 
- 자바 빈즈 패턴에서는 객체 하나를 만들려면 메서드를 여러개 호출해야 하고, 객체가 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓이게 된다. 
<br>-> 자바빈즈 패턴에서는 클래스를 불변으로 만들 수 없으며, 스레드 안전성을 얻으려면 프로그래머가 추가 작업을 해줘야 함
- 빌더 패턴 : 클라이언트는 필요한 객체를 직접 만드는 대신, 필수 매개변수만으로 생성자(or 정적팩토리)를 호출해 빌더 객체를 얻는다. 
<br>  빌더 패턴은 명명된 선택적 매개변수를 흉내낸 것이다. 

<pre>생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면, 빌더 패턴을 선택하는 게 낫다.</pre>

### 아이템 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라 
* 싱글턴 ? 인스턴스를 오직 하나만 생성 할 수 있는 클래스를 말함. 
- 클래스를 싱글턴으로 만들 경우 사용하는 클라이언트를 테스트하기 어려울 수 있음. 
1. 생성자는 private으로 가무처두고 유일한 이스턴스에 접근 할 수 있는 수단으로 public static 멤버를 하나 마련해 둔다. 
   - 장점 
     1. 해당 클래스가 싱글턴임을 명백히 들어남
     2. 간결함 
2. 정적 팩터리 메서드를 public static 멤버로 제공한다. 
   - 장점 
     1. api 를 바꾸지 않고 싱글턴이 아니게 변경 가능 
     2. 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있음(아이템30)
     3. 정적 팩터리의 메서드 참조를 공급자로 사용 할 수 있다. ex) Elvis::getInstance => Supplier<Elivs>로 사용 가능
   
둘 중 하나의 방식으로 싱글턴 클래스를 지결ㄹ화 하려면 단순히 Serializable을 구현한다고 선언하는 것만으로 부족하다.
모든 인스턴스 필드를 일시적(transient)이라고 선언하고 readREsolve 메서드를 제공해야 한다. 
이렇게 하지 않으면, 직렬화된 인스턴스를 역직렬화 할때마다 새로운 인스턴스가 만들어진다. 

3. 원소가 하나인 연거 타입을 선언하는 것
    - 장점 
        1. public 필드와 비슷하지만, 더 간결함
        2.  추가 노력없이 직렬화 가능
        3. 아주 복잡한 직렬화 상황이나 리플렉션 고역ㄱ에도 제 2의 인스턴스가 생기는 일을 완벽히 막아줌
   
대부분 상황에서는 원소가 하나뿐인 여거 타입이 싱글턴을 만드는 가장 좋은 방법 
단, 싱글턴이 Enum 이외의 클래스를 상속해야 한다면, 이 방법은 사용할 수 없음


### 아이템 4. 인스턴스화를 막으려 거든 private 생성자를 사용하라 
정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한 게 아님. 
<br>하지만, 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어줌
<br>즉, 매개변수를 받지 않은 public 생성자가 만들어지며, 사용자는 이 생성자가 자동으로 생성 된것인지 구분 할 수 없음
<br>추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없음 ,
<br><br>**private 생성자를 쿠가하면 클래스의 인스턴스화를 막을 수 있다**
1. 어떤 환경에서도 클래스가 인스턴스화 되는 것을 막아준다.
2. 상속을 불가능 하게하는 효과도 있다. 


### 아이템 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용 하라. 

